import pytest
from httpx import AsyncClient, Response, ASGITransport
from unittest.mock import patch, AsyncMock
from app.main import app

@pytest.mark.asyncio
async def test_execution_delegates_to_piston():
    """
    Verifies that the execution logic now calls the Piston service
    instead of running subprocesses locally.
    """
    mock_piston_response = {
        "run": {
            "stdout": "Hello Secure World",
            "stderr": "",
            "code": 0
        }
    }

    # Patch the AsyncClient specifically inside the piston service
    # This leaves the test's AsyncClient unaffected
    with patch("app.services.piston.httpx.AsyncClient") as MockClientClass:
        # Setup the mock client to return our response
        mock_client = MockClientClass.return_value
        mock_client.__aenter__.return_value = mock_client
        
        # Create a proper Response with a Request attached (needed for raise_for_status)
        from httpx import Request
        mock_response = Response(200, json=mock_piston_response)
        mock_response._request = Request("POST", "http://piston:2000/api/v2/execute")
        
        # Ensure 'post' is an async mock that returns our Response
        mock_client.post = AsyncMock(return_value=mock_response)

        async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
            payload = {
                "code": "print('Hello Secure World')",
                "language": "python"
            }
            response = await ac.post("/api/execute", json=payload)
            
            assert response.status_code == 200
            data = response.json()
            assert data["output"] == "Hello Secure World"
            
            # Verify the mock was called with correct URL
            call_args = mock_client.post.call_args
            assert "piston:2000/api/v2/execute" in str(call_args)
